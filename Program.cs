//namespace Types
//{
//    class Cat /*: Object */ // за замовчуванням, клас якщо не позначено успадукування, то він буде нащадком типу Обджект
//    {
//        // в класі всі компоненти за замовчуванням приватні
//        // прийнято писати модифікатор доступу перед КОЖНИМ компонентом (нема секцій, як в С++)
//        // для полів можна нічого не вказувати
//        private string name = "Barsik";
//        private int paws = 4;

//        // метод ToString присутній в батьківському класі Обджект, і там він позначений як virtual
//        public override string ToString()
//        {
//            return "Cat nick: " + name + ", it has " + paws + " paws";
//        }
//    }

//    class Program
//    {
//        static void Main(string[] args)
//        {
//            Cat c = new Cat();
//            Console.WriteLine(c); // по дефолту видає Types.Cat
//                                  // але якщо зробити перевизначення, то райтлайн покаже те що нам потрібно

//            Console.WriteLine(c.GetType().FullName);
//        }
//    }
//}
// ---------------------------------------------------------------------------------------------
//namespace Types
//{
//    class Cat
//    {
//        private string name = "Barsik";
//        private int paws = 4;

//        public override string ToString()
//        {
//            return "Cat nick: " + name + ", it has " + paws + " paws";
//        }

//        public void SetName(string name)
//        {
//            // поле = параметр
//            this.name = name;
//        }

//        public void SetPaws(int paws)
//        {
//            // як завжди, в сеттері зазвичай присутні перевірки
//            if (paws <= 0 || paws > 8)
//                paws = 4;
//            this.paws = paws;
//        }

//        public string GetName() // const - методів нема як в С++
//        {
//            return name;
//        }

//        public int GetPaws()
//        {
//            return paws;
//        }

//        // якщо в класі зробити явно конструктор з параметрами, то
//        // конструктор без параметрів за замовчуванням компілятором ВЖЕ НЕ НАДАЄТЬСЯ
//        // але так тільки для класів (для структур ЗАВЖДИ БУДЕ конструктор без параметрів - при будь яких умовах, є конструктори, нема їх)
//        public Cat(string name, int paws)
//        {
//            SetName(name);
//            SetPaws(paws);
//        }

//        // приклад делегування конструкторів
//        public Cat() : this("Barsik", 4) // public: Cat() : Cat("Barsik", 4)
//        {
//        }

//        //public Cat()
//        //{
//        //    SetName("Barsik");
//        //    SetPaws(4);
//        //}
//    }

//    class Program
//    {
//        static void Main(string[] args)
//        {
//            Cat c = new Cat();
//            Console.WriteLine(c); // по дефолту видає Types.Cat
//                                  // але якщо зробити перевизначення, то райтлайн покаже те що нам потрібно

//            Console.WriteLine(c.GetType().FullName);
//        }
//    }
//}
// ---------------------------------------------------------------------------------------------
//namespace Types
//{
//    class Cat
//    {
//        private string name = "Barsik";
//        private int paws = 4;
//        public override string ToString()
//        {
//            return "Cat nick: " + name + ", it has " + paws + " paws";
//        }
//        public void SetName(string name)
//        {
//           // поле = параметр
//            this.name = name;
//        }
//        public void SetPaws(int paws)
//        {
//            // як завжди, в сеттері зазвичай присутні перевірки
//            if (paws <= 0 || paws > 8)
//                paws = 4;
//            this.paws = paws;
//        }
//        public string GetName() // const - методів нема як в С++
//        {
//            return name;
//        }
//        public int GetPaws()
//        {
//            return paws;
//        }
//        // якщо в класі зробити явно конструктор з параметрами, то
//        // конструктор без параметрів за замовчуванням компілятором ВЖЕ НЕ НАДАЄТЬСЯ
//        // але так тільки для класів (для структур ЗАВЖДИ БУДЕ конструктор без параметрів - при будь яких умовах, є конструктори, нема їх)
//        public Cat(string name, int paws)
//        {
//            SetName(name);
//            SetPaws(paws);
//        }
//        // приклад делегування конструкторів
//        public Cat() : this("Barsik", 4) // public: Cat() : Cat("Barsik", 4)
//        {
//        }
//        //public Cat()
//        //{
//        //    SetName("Barsik");
//        //    SetPaws(4);
//        //}
//    }
//    class Program
//    {
//        static void Main(string[] args)
//        {
//            Cat c = new Cat();
//            // якщо тип даних Кіт було ЗРОБЛЕНО НА КЛАСІ, то тоді в рядку вище буде ДВІ СУТНОСТІ
//            // справа від значка = дорівнює буде створено ОБ'ЄКТ з типом Кіт, цей об'єкт безименний, при бажанні можна передати параметри (якщо є відповідний конструктор), ОБ'ЄКТ буде розміщено в області пам'яті під назвою ХІП (КУПА, HEAP), оператор new створює об'єкт, розміщує його в пам'яті В РАНТАЙМІ, і конструктор ініціалізує поля, оператор поверне АДРЕСУ цього об'єкта в хіпі

//            // зліва від значка = буде ЗМІННА посилального типу (с), і ФАКТИЧНО ЦЕ ПОКАЖЧИК на об'єкт класа Кіт, але максимально безпечний, без арифметики покажчиків, яка приносила лише біль та страждання ))
//            // & * * ++ -- додати ціле число, відняти ціле число, покажчик мінус покажчик
//            // АДРЕСНА АРИФМЕТИКА залишилася в С++
//            // на С++ код на 62 рядку виглядав би так:
//            // Cat* c = new Cat(); 
//            // в даному випадку, посилання (він жеж покажчик), зберігається на стеке (розмір якого як завжди 1 МБ, але для посилань цтого місця вистачить, одне посилання важить 8Б)
//            // ЄДИНЕ ЗАВДАННЯ ЗМІННИХ посилального типу - ЗБЕРІГАТИ АДРЕСУ ОБ'ЄКТА якогось класу (без всяких зайвих речей ++ -- тощо)
//            c.SetPaws(5);
//            c.SetName("Murzik");
//            Cat test; // ОБЕРЕЖНО! тому що тут нема об'єкта! є лише посилання (покажчик) НА ЯКИЙСЬ ОБ'ЄКТ ЯКИЙ МОЖЛИВО з'явиться в майбутньому
//            // Cat* test;
//            // test.SetPaws(4); // COMPILE ERROR!!!
//            Console.WriteLine(c); // по дефолту видає Types.Cat
//            // але якщо зробити перевизначення, то райтлайн покаже те що нам потрібно
//            Console.WriteLine(c.GetType().FullName);
//            // Cat c = new Cat();
//            // дві сутності:
//            // справа об'єкт і ВІН ЗБЕРІГАЄ СВОЇ ДАНІ (поля, стан)
//            // зліва змінна посилального типу (просто покажчик) і ВОНА ЗБЕРІГАЄ ЛИШЕ АДРЕСУ ОБ'ЄКТА (ніяких там нема полів, все що вона знає, що десь в хіпі є об'єкт)
//            // поведінка оператора =
//            // конструкторів копіювання (по дефолту) в дот нет не заплановано (можна зробити кастомний свій)
//            Cat d = c; // якщо тип Кіт це клас, то відбудеться КОПІЮВАННЯ АДРЕСИ з покажчика с в покажчик d
//            // Cat d = new Cat(c); // для створення ще одного об'єкта ОБОВ'ЯЗКОВО доведеться викликати оператор нью,
//            // а якщо потрібно КОПІЮВАННЯ ДАНИХ, то треба передбачити ЯВНИЙ конструктор з параметром типу Кіт (і там уже реалізуємо або поверхневе, або глибоке копіювання)
//            Console.WriteLine(c);
//            d.SetPaws(3);
//            d.SetName("Tom");
//            Console.WriteLine(c); // Tom 3
//            // особливість яка: через одне посилання можна змінити дані оригінального об'єкта 
//            // І ЦІ ЗМІНИ БУДУТЬ ВИДИМІ ЧЕРЕЗ УСІ існуючі посилання на об'єкт (в коді їх зараз 2!)
//            // як себе поводить оператор ==:
//            // для класів (і в цілому для ПОСИЛАЛЬНИХ типів) відбувається ПОРЯВНЯННЯ АДРЕС !!!
//            if (c == d) // тут відбувається порівняння ПОКАЖЧИКІВ, а не ОБ'ЄКТІВ!!!
//            { // при бажанні можна буде зробити перевантаження оператора == (але не =), для порівняння даних, а не адрес
//                Console.WriteLine("EQUALS!!!"); // але, це ж один і той самий об'єкт
//            }
//            Cat e = new Cat("Barsik", 4);
//            Cat f = new Cat("Barsik", 4);
//            if (e == f) // :600 == :700
//            {
//                Console.WriteLine("NOT EQUALS!!! Barsik Barsik");
//                // було створено два нових об'єкта, і не дивлячись на стан, у НИХ РІЗНІ АДРЕСИ
//                // так як адреси різні, то ми в цей ІФ не потрапимо!
//            }
//        }
//    }
//}
// ---------------------------------------------------------------------------------------------
//namespace Types
//{
//    struct Cat
//    {
//        // відмінність 1: - тепер структури в дот нет ТАК САМО з приватними компонентами ПО ДЕФОЛТУ
//        public string name = "Barsik";
//        public int paws = 4;

//        public override string ToString()
//        {
//            return "Cat nick: " + name + ", it has " + paws + " paws";
//        }

//        public void SetName(string name)
//        {
//            // поле = параметр
//            this.name = name;
//        }

//        public void SetPaws(int paws)
//        {
//            // як завжди, в сеттері зазвичай присутні перевірки
//            if (paws <= 0 || paws > 8)
//                paws = 4;
//            this.paws = paws;
//        }

//        public string GetName() // const - методів нема як в С++
//        {
//            return name;
//        }

//        public int GetPaws()
//        {
//            return paws;
//        }

//        // якщо в структурі зробити явно конструктор з параметрами, то
//        // конструктор без параметрів за замовчуванням компілятором ВСЕ ОДНО НАДАЄТЬСЯ - відмінність 2
//        public Cat(string name, int paws)
//        {
//            SetName(name);
//            SetPaws(paws);
//        }
//    }

//    class Program
//    {
//        static void Main()
//        {
//            Cat c = new Cat();

//            // якщо тип даних Кіт було ЗРОБЛЕНО НА СТРУКТУРІ, то тоді в рядку вище буде ЛИШЕ ОДНА СУТНІСТЬ!!!
//            // справа від значка = може бути а може і не бути присутній ВИКЛИК КОНСТРУКТОРА, який все що робить - ініціалізує об'єкт структури тими значеннями що потрібні програмісту
//            // по відношенню структур НЬЮ не створює об'єкт, не розміщує цей об'єкт в пам'яті!!! все що робить нью для структур - викликає конструктор (і то це не обов'язково!)

//            // зліва від значка = буде ЗМІННА ЗНАЧИМОГО типу (с), і ФАКТИЧНО ЦЕ САМ ОБ'ЄКТ СТРУКТУРИ Кіт, який буде займатися збереженням ЗНАЧЕНЬ
//            // в даному випадку, об'єкт структури Cat c лежить на стеке (але буває по різному, наприклад, якщо об'єкт структури є полем певного класу, то при створенні об'єкта цього класу, об'єкт структури ПАКУЄТЬСЯ (боксується) і відпрвляється в хіп
//            // на С++ код на 51 рядку виглядав би так:
//            // Cat c; 
//            // ....................................................

//            // ЗАВДАННЯ ЗМІННИХ СТРУКТУРНОГО типу - ЗБЕРІГАТИ САМІ ДАНІ (ЗНАЧЕННЯ ПОЛІВ) ОБ'ЄКТА
//            c.SetPaws(5);
//            c.SetName("Murzik");

//            Cat test; // об'єкт СТВОРЮЄТЬСЯ, розміщується на стеке, АЛЕ!!! без виклику конструктора або запису даних в УСІ поля - використання об'єкта структури неможливе!
//            test.paws = 4;
//            test.name = "Loki";
//            // test.SetPaws(4); // буде COMPILE ERROR!!! допоки не запишуться дані в поля, для цього треба АБО явно викликати будь який існуючий конструктор, або зробити поля публічними (що небажано), і позаписувати в них дані самостійно

//            Console.WriteLine(test); // Loki 4
//                                     // порада: все ж таки робити поля структури приватними, і викликати явно певний конструктор

//            // Cat c = new Cat();
//            // одна сутність ЯКЩО ЦЕ СТРУКТУРА а не клас:

//            // зліва об'єкт і ВІН ЗБЕРІГАЄ СВОЇ ДАНІ (поля, стан)
//            // справа - лише опціональний виклик конструктора

//            // поведінка оператора =

//            // конструкторів копіювання (по дефолту) в дот нет не заплановано (можна зробити кастомний свій) - ні для класів, ні для структур
//            Cat d = c; // якщо тип Кіт це СТРУКТУРА, то відбудеться ПОВЕРХНЕВЕ КОПІЮВАННЯ всіх полів з ОБ'ЄКТА с в ОБ'ЄКТ d
//            // тобто, d - ЦЕ ІЩЕ ОДИН ОКРЕМИЙ ОБ'ЄКТ, а якщо це окремий об'єкт, то в нього СВІЙ ОКРЕМИЙ СТАН !!!
//            d.SetPaws(3);
//            d.SetName("Tom");
//            Console.WriteLine(c); // Murzik 5
//            Console.WriteLine(d); // Tom 3
//            c.SetPaws(4);
//            c.SetName("Leo");
//            Console.WriteLine(c); // Leo 4
//            Console.WriteLine(d); // Tom 3, стан окремого об'єкта не змінився, бо це КОПІЯ а не посилання (покажчик)

//            // особливість яка: можна змінити дані оригінального об'єкта (напряму, бо посиланнь ніких немає!)
//            // АЛЕ ЦІ ЗМІНИ БУДУТЬ ВИДИМІ ЛИШЕ на цьому об'єкті!!!

//            // як себе поводить оператор ==:
//            // для структур по дефолту буде ПОМИЛКА при спробі порівняти дані об'єктів! 
//            // але, якщо буде потрібно, то можна ПЕРЕВИЗНАЧИТИ цю операцію

//            // if (c == d) // тут відбувається помилка на етапі компіляціі
//        }
//    }
//}
// ---------------------------------------------------------------------------------------------
//namespace Types
//{
//    struct Cat
//    {
//        // відмінність 1: - тепер структури в дот нет ТАК САМО з приватними компонентами ПО ДЕФОЛТУ
//        public string name = "Barsik";
//        public int paws = 4;

//        public override string ToString()
//        {
//            return "Cat nick: " + name + ", it has " + paws + " paws";
//        }

//        public void SetName(string name)
//        {
//            // поле = параметр
//            this.name = name;
//        }

//        public void SetPaws(int paws)
//        {
//            // як завжди, в сеттері зазвичай присутні перевірки
//            if (paws <= 0 || paws > 8)
//                paws = 4;
//            this.paws = paws;
//        }

//        public string GetName() // const - методів нема як в С++
//        {
//            return name;
//        }

//        public int GetPaws()
//        {
//            return paws;
//        }

//        // якщо в структурі зробити явно конструктор з параметрами, то
//        // конструктор без параметрів за замовчуванням компілятором ВСЕ ОДНО НАДАЄТЬСЯ - відмінність 2
//        public Cat(string name, int paws)
//        {
//            SetName(name);
//            SetPaws(paws);
//        }
//    }

//    class Program
//    {
//        static void AnotherFunction(ref Cat cat) // параметр цього метода - це ОРИГІНАЛ об'єкта структури ІЗ МЕЙНА !!!
//        {
//            cat.SetPaws(5); // сеттери викликаються, і змінюють оригінал!!!
//            cat.SetName("Alex");
//        } // при виході з методу, нема копії, щоб її знищити

//        static void Main()
//        {
//            Cat c = new Cat("Barsik", 4);
//            Console.WriteLine(c); // Barsik 4
//            AnotherFunction(ref c); // ЯВНА передача за посиланням, а не за значенням (відбувається не КОПІЮВАННЯ об'єкта структури, а його передача за посиланням - тобто метод БУДЕ працювати з оригіналом !!!
//            Console.WriteLine(c); // Алекс 5 лапок
//        }
//    }
//}
// ---------------------------------------------------------------------------------------------
//namespace Types
//{
//    class Cat // CLASS !!!
//    {
//        string name = "Barsik";
//        int paws = 4;

//        public override string ToString()
//        {
//            return "Cat nick: " + name + ", it has " + paws + " paws";
//        }

//        public void SetName(string name)
//        {
//            this.name = name;
//        }

//        public void SetPaws(int paws)
//        {
//            this.paws = paws;
//        }

//        public string GetName()
//        {
//            return name;
//        }

//        public int GetPaws()
//        {
//            return paws;
//        }

//        public Cat(string name, int paws)
//        {
//            SetName(name);
//            SetPaws(paws);
//        }
//    }

//    class Program
//    {
//        static void AnotherFunction(Cat cat) // параметр cat - це ІЩЕ одне посилання (він жеж покажчик) на той самий об'єкт КЛАСА із мейна
//        {
//            cat.SetPaws(5); // через покажчик (посилання) ЗМІНЮЄТЬСЯ ОРИГІНАЛ ОБ'ЄКТА без всяких рефів
//            cat.SetName("Alex");
//        } // при виході з метода дещо знищиться: а саме ДОДАТКОВИЙ покажчик на оригінал об'єкта (сама адреса не знищиться, і об'єкт теж)

//        static void Main()
//        {
//            Cat c = new Cat("Barsik", 4);
//            // так як тип Кіт - це знову клас, то буде дві сутності, нью зробить об'єкт, поверне його адресу, адреса пишеться В ПОСИЛАННЯ (покажчик)
//            Console.WriteLine(c); // Barsik 4
//            AnotherFunction(c); // ПЕРЕДАЄТЬСЯ ПОСИЛАННЯ на об'єкт класа (АДРЕСА) - в С++ це б назвали передача покажчика
//            Console.WriteLine(c); // оригінал уже було змінено в методі, тому всі зміни збережуться
//        }
//    }
//}
// ---------------------------------------------------------------------------------------------
//namespace Types
//{
//    class Cat // CLASS !!!
//    {
//        string name = "Barsik";
//        int paws = 4;

//        public override string ToString()
//        {
//            return "Cat nick: " + name + ", it has " + paws + " paws";
//        }

//        public void SetName(string name)
//        {
//            this.name = name;
//        }

//        public void SetPaws(int paws)
//        {
//            this.paws = paws;
//        }

//        public string GetName()
//        {
//            return name;
//        }

//        public int GetPaws()
//        {
//            return paws;
//        }

//        public Cat(string name, int paws)
//        {
//            SetName(name);
//            SetPaws(paws);
//        }
//    }

//    class Program
//    {
//        static void AnotherFunction(in Cat cat)
//        {
//            // cat = new Cat("Barsik", 4); // якщо треба заборонити запис нових в параметр-покажчик, то можна позначити параметр як іn
//            // але нажаль оцей іn ніяк не забороняє змінювати ОБ'ЄКТ через цей покажчик (в сам покажчик нічого не можна записати)
//            cat.SetPaws(5); // через покажчик (посилання) ЗМІНЮЄТЬСЯ ОРИГІНАЛ ОБ'ЄКТА без всяких рефів
//            cat.SetName("Alex");
//        }

//        static void Main()
//        {
//            Cat c = new Cat("Barsik", 4);
//            // так як тип Кіт - це знову клас, то буде дві сутності, нью зробить об'єкт, поверне його адресу, адреса пишеться В ПОСИЛАННЯ (покажчик)
//            Console.WriteLine(c); // Barsik 4
//            AnotherFunction(c); // ПЕРЕДАЄТЬСЯ ПОСИЛАННЯ на об'єкт класа (АДРЕСА) - в С++ це б назвали передача покажчика
//            Console.WriteLine(c); // оригінал уже було змінено в методі, тому всі зміни збережуться
//        }
//    }
//}
// ---------------------------------------------------------------------------------------------
//якщо тип створений на класі, це прямий нащадок Object (або іншого класу, ім'я якого явно вказано при успадкуванні)

//якщо тип створений на СТРУКТУРІ, це непрямий нащадок Object, але прямий нащадок типу ValueType (структуру неможливо успадкувати явно від чогось іншого)
// ValueType - це спеціальний тип в дот нет, який є нащадком Object, і від нього успадковуються ВСІ СТРУКТУРИ
// ValueType - це ТЕ, ЩО ВІДРІЗНЯЄ СТРУКТУРИ ВІД КЛАСІВ
// ----------------------------------------------------------------------------------------------
//namespace Types
//{
//    class Program
//    {
//        static void Main()
//        {
//            Console.WriteLine(10); // int
//            Console.WriteLine(10F); // float
//            Console.WriteLine(10D); // double
//            Console.WriteLine(10M); // decimal
//            Console.WriteLine(10L); // long
//            Console.WriteLine(10UL); // ulong
//            Console.WriteLine(10U); // uint

//            // float f = 3.14; // неявне звужуюче перетворення НЕ ПРАЦЮЄ !!
//        }
//    }
//}
// ----------------------------------------------------------------------------------------------
